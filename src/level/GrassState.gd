extends LevelState

const Grass = preload("res://src/row/Grass.tscn")
const Hedge = preload("res://src/row/entity/Hedge.tscn")

var _type
var _hedge_index
var _hedge_layout
var _first_row

const NEXT_STATE = ["road", "water"]

func start():
    _first_row = true
    _hedge_index = null
    _hedge_layout = null
    _type = randi() % 7

func get_row():
    var row = Grass.instance()
    row.type = _type
    _add_hedge_tiles(row)
    _type = _get_next_type(_type)
    if _type == null:
        .change_state(_get_next_state())


    _first_row = false
    return row

func _add_hedge_tiles(row):
    if not _first_row and _hedge_index == null:
        if randf() < 0.5 and _type > 7 and _type < 14:
            _hedge_layout = _generate_hedge_layout()
            _hedge_index = 0
    elif _hedge_index == 0:
        _hedge_index = 1
    else:
        _hedge_index = null
    
    if _hedge_index != null:
        var previous_mid_segment = null
        for i in range(1, 13):
            var r = _classify_hedge_segment(_hedge_layout.slice(i-1, i+3), previous_mid_segment)
            var sprite = r[0]
            previous_mid_segment = r[1]
            if sprite != null:
                var hedge = Hedge.instance()
                hedge.set_tile(sprite, _hedge_index)
                hedge.position.x = i * 40 - 40
                hedge.position.y = 0
                row.add_child(hedge)
                row.move_child(hedge,0)
                
                # self.children.append(Hedge(sprite_x, self.hedge_row_index, (i * 40 - 20, 0)))

func _classify_hedge_segment(hedge, previous_mid_segment):
    var sprite
    if hedge[1]:
        sprite = null
    else:
        var hedge_0 = 1 if hedge[0] else 0
        var hedge_2 = 1 if hedge[2] else 0
       
        sprite = 3 - 2 * hedge_0 - hedge_2

    if sprite == 3:
        if previous_mid_segment == 4 and hedge[3]:
            return [5, null]
        else:
            if previous_mid_segment == null or previous_mid_segment == 4:
                sprite = 3
            elif previous_mid_segment == 3:
                sprite = 4
            return [sprite, sprite]
    else:
        return [sprite, null]

# def classify_hedge_segment(mask, previous_mid_segment):
# # This function helps determine which sprite should be used by a particular hedge segment. Hedge sprites are numbered
# # 00, 01, 10, 11, 20, 21 - up to 51. The second number indicates whether it's a bottom (0) or top (1) segment,
# # but this method is concerned only with the first number. 0 represents a single-tile-width hedge. 1 and 2 represent
# # the left-most or right-most sprites in a multi-tile-width hedge. 3, 4 and 5 all represent middle pieces in hedges
# # which are 3 or more tiles wide.

# # mask is a list of 4 boolean values - a slice from the list generated by generate_hedge_mask. True represents a gap
# # and False represents a hedge. mask[1] is the item we're currently looking at.
# if mask[1]:
#     # mask[1] == True represents a gap, so there will be no hedge sprite at this location
#     sprite_x = None
# else:
#     # There's a hedge here - need to check either side of it to see if it's a single-width, left-most, right-most
#     # or middle piece. The calculation generates a number from 0 to 3 accordingly. Note that when boolean values
#     # are used in arithmetic in Python, False is treated as being 0 and True as 1.
#     sprite_x = 3 - 2 * mask[0] - mask[2]

# if sprite_x == 3:
#     # If this is a middle piece, to ensure the piece tiles correctly, we alternate between sprites 3 and 4.
#     # If the next piece is going to be the last of this hedge section (sprite 2), we need to make sure that sprite 3
#     # does not precede it, as the two do not tile together correctly. In this case we should use sprite 5.
#     # mask[3] tells us whether there's a gap 2 tiles to the right - which means the next tile will be sprite 2
#     if previous_mid_segment == 4 and mask[3]:
#         return 5, None
#     else:
#         # Alternate between 3 and 4
#         if previous_mid_segment == None or previous_mid_segment == 4:
#             sprite_x = 3
#         elif previous_mid_segment == 3:
#             sprite_x = 4
#         return sprite_x, sprite_x
# else:
#     # Not a middle piece
#     return sprite_x, None

func _generate_hedge_layout():
    var initial_layout = []
    for _i in range(12):
        initial_layout.append(randf() < 0.01)
    
    initial_layout[randi() % 12] = true


    var layout = []
    for i in range(12):
        if initial_layout[max(0, i-1)] || initial_layout[min(11, i+1)] || initial_layout[i]:
            layout.append(true)
        else:
            layout.append(false)

    
    return [layout[0]] + layout + [layout[-1]] + [layout[-1]]


func _get_next_type(type):
    if type <= 5:
        return type + 8
    elif type == 6:
        return 7
    elif type == 7:
        return 15
    elif type >= 8 and type <= 14:
        return type + 1
    else:
        return null

func _get_next_state():
    return NEXT_STATE[randi() % NEXT_STATE.size()]


    # self.hedge_row_index = None     # 0 or 1, or None if no hedges on this row
    # self.hedge_mask = None

    # if not isinstance(predecessor, Grass) or predecessor.hedge_row_index == None:
    #     # Create a brand-new set of hedges? We will only create hedges if the previous row didn't have any.
    #     # We also only want hedges to appear on certain types of grass row, and on only a random selection
    #     # of rows
    #     if random() < 0.5 and index > 7 and index < 14:
    #         self.hedge_mask = generate_hedge_mask()
    #         self.hedge_row_index = 0
    # elif predecessor.hedge_row_index == 0:
    #     self.hedge_mask = predecessor.hedge_mask
    #     self.hedge_row_index = 1

    # if self.hedge_row_index != None:
    #     # See comments in classify_hedge_segment for explanation of previous_mid_segment
    #     previous_mid_segment = None
    #     for i in range(1, 13):
    #         sprite_x, previous_mid_segment = classify_hedge_segment(self.hedge_mask[i - 1:i + 3], previous_mid_segment)
    #         if sprite_x != None:
    #             self.children.append(Hedge(sprite_x, self.hedge_row_index, (i * 40 - 20, 0)))
